1. 编写一个具有单一类型模板参数的一元函数模板。用类型int生成它的一个完全特化。再为这个拥有单一的int参数的函数产生一个非模板重载。在主函数中调用这三个函数。
2. 编写一个持有单一类型参数（T)的函数模板，它接受了4个函数参数：一个T类数组，一个开始索引值，一个结束索引值（在允许范围之内的）和一个可选择的初始值。函数返回指定范围内所有数组元素值和初始值的和。用默认构造函数为T类型的数据用默认方式赋初值。
3. 重做上面的习题，使用显示实例化手工生成int和double的特化。
4. 编写一些持有下列多种无类型参数的模板：一个int、一个指向int的指针、一个指向int类型的静态类成员的指针和一个指向一个静态成员函数的指针。
5. 定义一个持有单一类型参数的类模板，将其命名为Bob。使Bob成为一个名为Friendly的模板类的所有实例的友元，并且成为一个名为Picky的类模板的友元——仅当Bob和Picky的类型参数完全相同的时候。提供一些能证明这些类的友元关系的Bob成员函数。
6. 指出下面的代码为什么无法编译？

```
template<class T> double pythag(T a, T b, T c){
    return (-b + sqrt(double(b*b - 4*a*c))) / 2*a;
}
int main(){
    pythag(1, 2, 3)
    pythag(1.0, 2.0, 3.0)
    pythag(1, 2.0, 3.0)
    pythag<double>(1, 2.0, 3.0);
}
```
7. 举例说明静态成员数据特化，类模板的特化，函数模板特化
8. 研究stl中的iostream，说明cout,endl,<<,hex分别是什么含义，解释下面的代码：
```
cout << "hello World" <<  hex << 123 << endl;
```
9. 使用运算符重载实现变体，支持int float char*等类型。
